//User files
#include "Constants.h"
#include "BoardV2.h"

//System libraries
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <avr/sleep.h>
#include <avr/wdt.h>
#include <avr/pgmspace.h>

//Modified RadioHead library
#include "./radiohead-ask-atmega328p/RadioHead.h"
#include "./radiohead-ask-atmega328p/RH_ASK.h"
#include "./radiohead-ask-atmega328p/RH_ASK.cpp"
#include "./radiohead-ask-atmega328p/RHCRC.h"
#include "./radiohead-ask-atmega328p/RHCRC.cpp"
#include "./radiohead-ask-atmega328p/RHGenericDriver.cpp"
#include "./radiohead-ask-atmega328p/RHGenericDriver.h"

#include "./pwmservo-atmega328p/PWMServo.h"
#include "./pwmservo-atmega328p/PWMServo.cpp"
#include <Wire.h>

//From documentation: RH_ASK (uint16_t speed=2000, uint8_t rxPin=11, uint8_t txPin=12, uint8_t pttPin=10, bool pttInverted=false)
//pttPin = -1 will disable push to talk functionality
RH_ASK ask_driver = RH_ASK(500, RECEIVER, TRANSMITTER, -1, false);

PWMServo servo;

volatile long lastButtonPressedTime = 0;
volatile bool lastButtonState = false;

volatile bool switchOn = false;
volatile bool debugOn = false;           

//ISR Toggles
volatile bool requestSwitchToggle = false;
volatile bool requestSwitchOn = false;
volatile bool requestSwitchOff = false;

volatile bool requestSerialOn = false;
volatile bool requestSerialOff = false;

const static char NEWLINE[] PROGMEM = "\n";

int main (void){
   
  
  initialize();

  //pinMode(BUZZER, OUTPUT);
  //beep(1,1000);
  
  while(true){
    beep(1,10);
    serialWriteString("1");
    _delay_ms(1000);
    //sleep();
  }
  
  
  
  /*
  while(true){
    //printAllREG();
    processISRUpdates();                    //Check for changes generated by the ISR
    
    transmitASKByte(WAKE_UP);               //WAKE_UP
    while(receiveASKByte() != ACK);         //Wait for ACK (Blocking with timeout)

    while(true){
      byte command = receiveASKByte();
      if(command == SLEEP){
        break;
      }else{
        if(processASKCommand(command)){
          transmitASKByte(ACK); 
        }else{
          transmitASKByte(NACK); 
        }
      }
    }
    transmitASKByte(ACK);


    if(debugOn) Serial.println("sleeping");
    delay(5000);
    //sleep();
  }
  */
}

void initialize() {
  MCUSR &= ~(1<<WDRF); //Always clear the watchdog system reset flag on startup, p45
  WDTCSR &= ~(1<<WDE); //Always clear the watchdog system reset mode on startup, p45

  //***************************Initialize IO***************************//
  pinMode(BUZZER, OUTPUT);
  pinMode(BUTTON, INPUT);
  attachInterrupt(digitalPinToInterrupt(BUTTON), buttonISR, CHANGE);
 
  enableSerial();                      //*********************FIX ME Should be disabled by default**********************
  
  pinMode(SERVO_ENABLE, OUTPUT);
  digitalWrite(SERVO_ENABLE, LOW);

 
  //***************************Initialize Radio***************************//
  pinMode(TRANSMITTER, OUTPUT);
  pinMode(RECEIVER, INPUT);
  ask_driver.init();

  
  
  //***************************Initialize BMS***************************//
  
  Wire.begin();
  pinMode(BMS_INTERRUPT,INPUT);
  attachInterrupt(digitalPinToInterrupt(BMS_INTERRUPT), bmsISR, RISING);
  pinMode(BMS_OTG, OUTPUT);
  digitalWrite(BMS_OTG, HIGH);        //*********************FIX ME (OTG shouldn't be on by default)**********************

  
  //setOTG_CONFIG(true);    //enable boost mode
  //setCHG_CONFIG(false);   //Disable charging
  //setCONV_RATE(true);     //enable continuous ADC for testing
  //enableWatchdog(false);  //Disable watchdog
  writeRegister(0x0A, 0x77); //Set BOOST_LIM value to 111 = 2.45A
 
  

  initializeTimer2Sleep();
  SMCR|=(1<<SM1)|(1<<SM0); //Set sleep mode control register to PowerSave Mode (Bits SM2 SM1 SM0 = 011 , p38)
  sei();   //Enable global interrupts

  //setSTAT_DIS(true);
  

}

void initializeTimer2Sleep(){
    //Disable timer2 interrupts by zeroing OCIE2A, OCIE2B and TOIE2
    TIMSK2  = 0;
    //Enable asynchronous mode, Only other R/W bit in ASSR is EXCLK which should be 0
    ASSR  = (1<<AS2);
    //set initial counter value
    TCNT2=0;
    //set OCR2B to 255, This value should set the frequency of the interrupts
    OCR2B = 0b11111111;
    //set prescaller 1024
    TCCR2B |= (1<<CS22) | (1<<CS21) | (1<<CS20);
    //wait for registers TCN2UB, OCR2BUB and TCR2BUB to update by checking status is ASSR
    while ( (1<<TCN2UB)&ASSR | (1<<TCR2BUB)&ASSR | (1<<TCR2BUB)&ASSR);
    //clear interrupt flags;  "Output Compare Flag 2 B" and "Timer/Counter2 Overflow Flag"
    TIFR2  = (1<<TOV2) | (1<<OCF2B);
    //enable OCIE2B interrupt to trigger when compare B matches
    TIMSK2  = (1<<OCIE2B);
}

void sleep(){
  initializeTimer2Sleep();
  cli();           //Disable global interrupts because timed sequence follows
  SMCR |= (1<<SE); //Set "Sleep Mode Control Register" Sleep Enable, SE, Bit = 1, p38
  sei();           //Garentees that the next instruction is executed
  sleep_cpu();     //Issue sleep instruction. This cannot be done by setting a register
  //asm volatile("sleep"::); //Assembly version of sleep_cpu();

        //Sleeping until interrupt

  SMCR &= ~(1<<SE); //Disable sleep enable after wakeup
}
ISR(TIMER2_COMPB_vect){    //fires on wakeup
    asm volatile("nop"::);
}

void processISRUpdates(){
  if(requestSwitchToggle){
    toggleSwitch();
    requestSwitchToggle = false;
  }
  if(requestSwitchOn){
    turnOn();
    requestSwitchOn = false;
  }
  if(requestSwitchOff){
    turnOff();
    requestSwitchOff = false;
  }
  if(requestSerialOn){
    enableSerial();
    requestSerialOn = false;
  }
}
void buttonISR(){
  /*
  bool buttonState = digitalRead(BUTTON);

  //digitalWrite(SERVO_ENABLE, !digitalRead(SERVO_ENABLE)); // Toggle the LED for testing

  if(buttonState == true && lastButtonState == false){  //RISING
    lastButtonPressedTime = millis();
  }
  if(buttonState == false && lastButtonState == true){  //FALLING
    if ((unsigned long)(millis() - lastButtonPressedTime) >= SERIAL_ENABLE_TIME){
        requestSerialOn = true;
    }else{
      requestSwitchToggle = true;
    }
  }
  lastButtonState = buttonState;
  */
}
void bmsISR(){
  
}
void toggleSwitch(){
  if(switchOn){
    beep(1, 10);
    //turnOff();
  }else{
    beep(2, 10);
    //turnOn();
  }
}
void turnOn(){
  servo.attach(SERVO);
  _delay_ms(15);
  digitalWrite(SERVO_ENABLE, HIGH);
  //servo.write(ONPOSITION - OVERSHOOT);
  //delay(OVERSHOOT_TIME);
  servo.write(ONPOSITION);
  _delay_ms(MOVE_TIME);
  digitalWrite(SERVO_ENABLE, LOW);
  servo.detach();
  switchOn = true;
}
void turnOff(){
  servo.attach(SERVO);
  _delay_ms(15);
  digitalWrite(SERVO_ENABLE, HIGH);
  //servo.write(OFFPOSITION + OVERSHOOT);
  //delay(OVERSHOOT_TIME);
  servo.write(OFFPOSITION);
  _delay_ms(MOVE_TIME);
  digitalWrite(SERVO_ENABLE, LOW);
  servo.detach();
  switchOn = false;
}
const static char Enable_Serial_Message [] PROGMEM = "Serial enabled";
void enableSerial(){
  serialBegin();
  serialWriteProgString(Enable_Serial_Message);
  debugOn = true;
}
const static char Disable_Serial_Message [] PROGMEM = "Goodbye";
void disableSerial(){
  serialWriteProgString(Disable_Serial_Message);
  //Serial.end();
  debugOn = false;
}
void beep(int num, int timeMillis){
    for(int i = 0; i < num; i++){
        digitalWrite(BUZZER, HIGH);
        _delay_ms(timeMillis);
        digitalWrite(BUZZER, LOW);
        if (i < num -1){
            _delay_ms(timeMillis*2);
        }
    }
}

//*********************************Conversion functions************************************************//
char outputString[80]; // general output string, 80 bytes

char* longToString(long n){
  ltoa(n, outputString, 10);    // base 10
  return outputString;
}
char* integerToString(int n){   // returns outputString
  itoa(n, outputString, 10);    // itoa is for integers, 10 is for base 10 (could use 2 for binary, 16 for hex)
  return outputString;
}
char* integerToHex(uint32_t n){ // can be any sort of number, long, byte, uint8,16,32 etc
  ltoa(n, outputString, 16);    // base 16 is binary, returns lower case A-F
  return outputString;
}

//*********************************Serial functions************************************************//
unsigned char serialCheckRxComplete(void){
  return( UCSR0A & _BV(RXC0)) ;         // nonzero if serial data is available to read.
}
unsigned char serialCheckTxReady(void){
  return( UCSR0A & _BV(UDRE0) ) ;       // nonzero if transmit register is ready to receive new data.
}
unsigned char serialReadChar(void){
  while (serialCheckRxComplete() == 0); // While data is NOT available to read
  return UDR0;
}
void serialWriteChar(unsigned char DataOut){
  while (serialCheckTxReady() == 0);   // while NOT ready to transmit
  UDR0 = DataOut;
}
void serialWriteString(const char* string){
  const char* ptr = string;
  while(*ptr != 0){
    serialWriteChar(*ptr);
    ptr++;
  }
}
void serialWriteProgString(const char* ptr){
  char c;
  if (!ptr) 
    return;
  while ((c = pgm_read_byte(ptr++)))
    serialWriteChar(c);
}
void serialBegin(){
  UBRR0H = (unsigned char)(CALC_UBRR>>8); //Set baud rate
  UBRR0L = (unsigned char) CALC_UBRR;     //Set baud rate
  UCSR0B = (1<<RXEN0)|(1<<TXEN0); //Enable receiver and transmitter
  UCSR0C = (3<<UCSZ00);           // Frame format: 8data, No parity, 1stop bit
  UCSR0A |= _BV(U2X0); //Enable USE_2X (Jared added this)
}


//*********************************RH_ASK wrapper functions****************************************//
bool processASKCommand(byte command){
    if(command == BEEP){
        beep(1, 10);
        return true;
    }else if(command == SWITCH_ON){
        turnOn();
        return true;
    }else if(command == SWITCH_OFF){
        turnOff();
        return true;
    }else if(command == SWITCH_TOGGLE){
        toggleSwitch();
        return true;
    }else{
        return false;
    }
}

byte receiveASKByte(){ //blocking
    uint8_t buf[1];
    uint8_t buflen = sizeof(buf);
    //if(debugOn) Serial.print("Receiving");
    
    long timeout = millis() + TIMEOUT;    
    while(!ask_driver.recv(buf, &buflen) && millis() < timeout){    // Non-blocking  
      if(debugOn){
        //Serial.print(".");
        _delay_ms(100);
      }
    }
    //if(debugOn) Serial.print("\n");
    return(buf[0]); 
}

void transmitASKByte(byte data){
    ask_driver.send(&data, 1);
    ask_driver.waitPacketSent();
}

byte checkASKByte(){
    uint8_t buf[1];
    uint8_t buflen = sizeof(buf);
    if(ask_driver.recv(buf, &buflen)){
        return(buf[0]); 
    }else{
        return NULL;
    }
}

//*********************************BMS functions****************************************//
byte readRegister(byte address){
  Wire.beginTransmission(BMS_ADDRESS);
  Wire.write(address);
  Wire.endTransmission();
  
  Wire.requestFrom(BMS_ADDRESS, 1);
  while(Wire.available()>1);
  
  return(Wire.read());
}
void writeRegister(byte address, byte value){
  Wire.beginTransmission(BMS_ADDRESS);
  Wire.write(address);
  Wire.write(value);
  Wire.endTransmission();
}

void writeRegisterBit(byte address, int pos, bool value){
  byte currentData = readRegister(address);         //Read the current state
  currentData = bitWrite(currentData, pos, value);  //Change the specified bit
  writeRegister(address, currentData);              //Write the changes
}

void setCONV_RATE(bool value){ //Configure continuous ADC updates = TRUE, one shot mode = FALSE
  writeRegisterBit(0x02, 6, value);
}
void setOTG_CONFIG(bool value){
  writeRegisterBit(0x03, 5, value);
}
void setCHG_CONFIG(bool value){
  writeRegisterBit(0x03, 4, value);
}
void setSTAT_DIS(bool value){
  writeRegisterBit(0x07, 6, value);
}
void setWD_RST(bool value){
  writeRegisterBit(0x03, 6, value);
}


void enableWatchdog(bool value){ //00 for disabled, 01 for 40s, 10 for 80s and 11 for 160s
  int bit5;
  int bit4;
  if(value){ 
     bit5 = 0;
     bit4 = 1;
  }else{
    bit5 = 0;
    bit4 = 0;
  }
  byte currentData = readRegister(0x07);         
  currentData = bitWrite(currentData, 5, bit5);  
  currentData = bitWrite(currentData, 4, bit4); 
  writeRegister(0x07, currentData);
}

//**********************************Print methods**********************************************//
void printAllREG(){
  serialWriteChar('\n');
  for(int i = 0; i < 50; i++) serialWriteChar('*');

  printREGBinary(0x00);
  printREGBinary(0x01);
  printREGBinary(0x02);
  printREGBinary(0x03);
  printREGBinary(0x04);
  printREGBinary(0x05);
  printREGBinary(0x06);
  printREGBinary(0x07);
  printREGBinary(0x08);
  printREGBinary(0x09);
  printREGBinary(0x0A);

  //Registers 0B to 14 are primarily read only,
  printREG0B();
  printREG0C();
  printREG0D();
  printREG0E();
  printREG0F();
  printREG10();
  printREG11();
  printREG12();
  printREG13();
  printREG14();
  serialWriteChar('\n');
  for(int i = 0; i < 50; i++) serialWriteChar('*');
}

const static char Register_[] PROGMEM = "Register ";
void printREGBinary(byte address){
  serialWriteChar('\n');
  byte data = readRegister(address);
  byte mask = 0b10000000;
  
  serialWriteProgString(Register_);
  serialWriteString("0x");
  serialWriteString(integerToHex(address));
  serialWriteString(": ");
  
  for(int i = 0; i<8; i++){
    if(((mask >> i) & data) == (mask>>i)){
      serialWriteChar("1");
    }else{
      serialWriteChar("0");
    }
  }
}

const static char Charger_Status_Message [] PROGMEM = "Charger status: ";
const static char No_Charger_Message [] PROGMEM = "No charger";
const static char USB_Host_SDP_Message [] PROGMEM = "USB Host SDP";
const static char USB_CDP_Message [] PROGMEM = "USB CDP (1.5A)";
const static char USB_DCP_Message [] PROGMEM = "USB DCP (3.25A)";
const static char MaxCharge_Message [] PROGMEM = "Adjustable High Voltage DCP (MaxCharge) (1.5A)";
const static char Unknown_Adapter_Message [] PROGMEM = "Unknown Adapter (500mA)";
const static char Non_Standard_Adapter_Message [] PROGMEM = "Non-Standard Adapter (1A/2A/2.1A/2.4A)";
const static char OTG_Mode_Message [] PROGMEM = "OTG mode";

const static char Charging_Mode_Message [] PROGMEM = "Charging mode: ";
const static char Not_Charging_Message [] PROGMEM = "Not Charging";
const static char Pre_Charging_Message [] PROGMEM = "Pre-charge";
const static char Fast_Charging_Message [] PROGMEM = "Fast Charging";
const static char Charge_Termination_Done_Message [] PROGMEM = "Charge Termination Done";

const static char Power_Status_Message [] PROGMEM = "Power status: ";
const static char Error_Message [] PROGMEM = "Error";
const static char Good_Message [] PROGMEM = "Good";

const static char VSYS_Message [] PROGMEM = "VSYS Regulation Status: ";
const static char No_VSYS_Reg_Message [] PROGMEM = "NOT in VSYSMIN regulation (BAT > VSYSMIN)";
const static char VSYS_Good_Message [] PROGMEM = "Good (BAT < VSYSMIN)";

void printREG0B(){
  byte data = readRegister(0x0B);
  serialWriteChar("\n");
  
  //print charger information
  serialWriteProgString(Charger_Status_Message);
  
  byte charger = data >> 5;
  if      (charger == 0) serialWriteProgString(No_Charger_Message);
  else if (charger == 1) serialWriteProgString(USB_Host_SDP_Message);
  else if (charger == 2) serialWriteProgString(USB_CDP_Message);
  else if (charger == 3) serialWriteProgString(USB_DCP_Message);
  else if (charger == 4) serialWriteProgString(MaxCharge_Message);
  else if (charger == 5) serialWriteProgString(Unknown_Adapter_Message);
  else if (charger == 6) serialWriteProgString(Non_Standard_Adapter_Message);
  else if (charger == 7) serialWriteProgString(OTG_Mode_Message);

  //print charging status
  serialWriteProgString(Charging_Mode_Message);
  byte chargeStatus = data << 3;
  chargeStatus = chargeStatus >> 6;
  if      (chargeStatus == 0) serialWriteProgString(Not_Charging_Message);
  else if (chargeStatus == 1) serialWriteProgString(Pre_Charging_Message);
  else if (chargeStatus == 2) serialWriteProgString(Fast_Charging_Message);
  else if (chargeStatus == 3) serialWriteProgString(Charge_Termination_Done_Message);

  //print power good
  serialWriteProgString(Power_Status_Message);
  byte powerStatus = data << 4;
  powerStatus = powerStatus >> 7;
  if      (powerStatus == 0) serialWriteProgString(Error_Message);
  else if (powerStatus == 1) serialWriteProgString(Good_Message);

  //print power good
  serialWriteProgString(VSYS_Message);
  byte vsysStatus = data << 7;
  vsysStatus = vsysStatus >> 7;
  if      (powerStatus == 0) serialWriteProgString(No_VSYS_Reg_Message);
  else if (powerStatus == 1) serialWriteProgString(VSYS_Good_Message);
}

const static char Watchdog_Message [] PROGMEM = "Watchdog status: ";
const static char Normal_Message [] PROGMEM = "Normal";
const static char Timer_Expired_Message [] PROGMEM = "Timer expired";

const static char Boost_Status_Message [] PROGMEM = "Boost status: ";
const static char VBUS_Overloaded_Message [] PROGMEM = "VBUS overloaded in OTG, or VBUS OVP, or battery is too low in boost mode";

const static char Input_Fault_Message [] PROGMEM = "Input fault";
const static char Thermal_Shutdown_Message [] PROGMEM = "Thermal shutdown";
const static char Charger_Safety_Message [] PROGMEM = "Charge safety timer expiration";

const static char Battery_Status_Message [] PROGMEM = "Battery status: ";
const static char Battery_Overvoltage_Message [] PROGMEM = "Battery over-voltage";

const static char NTC_Status_Message [] PROGMEM = "NTC status: ";
const static char TS_Warm_Message [] PROGMEM = "TS Warm";
const static char TS_Cool_Message [] PROGMEM = "TS Cool";
const static char TS_Cold_Message [] PROGMEM = "TS Cold";
const static char TS_Hot_Message [] PROGMEM = "TS Hot";

void printREG0C(){
  byte data = readRegister(0x0C);
  serialWriteChar("\n");
  
  //print watchdog status
  serialWriteProgString(Watchdog_Message);
  byte watchdog = data >> 7;
  if      (watchdog == 0) serialWriteProgString(Normal_Message);
  else if (watchdog == 1) serialWriteProgString(Timer_Expired_Message);

  //print boost status
  serialWriteProgString(Boost_Status_Message);
  byte boost = data << 1;
  boost = boost >> 7;
  if      (boost == 0) serialWriteProgString(Normal_Message);
  else if (boost == 1) serialWriteProgString(VBUS_Overloaded_Message);

  //print charger status
  serialWriteProgString(Charger_Status_Message);
  byte charger = data << 2;
  charger = charger >> 6;
  if      (charger == 0) serialWriteProgString(Normal_Message);
  else if (charger == 1) serialWriteProgString(Input_Fault_Message);
  else if (charger == 2) serialWriteProgString(Thermal_Shutdown_Message);
  else if (charger == 3) serialWriteProgString(Charger_Safety_Message);

  //print battery status
  serialWriteProgString(Battery_Status_Message);
  byte battery = data << 4;
  battery = battery >> 7;
  if      (battery == 0) serialWriteProgString(Normal_Message);
  else if (battery == 1) serialWriteProgString(Battery_Overvoltage_Message);

  //print temperature sensor status
  serialWriteProgString(NTC_Status_Message);
  byte ntc = data << 5;
  ntc = ntc >> 5;
  if      (ntc == 0) serialWriteProgString(Normal_Message);
  else if (ntc == 2) serialWriteProgString(TS_Warm_Message);
  else if (ntc == 3) serialWriteProgString(TS_Cool_Message);
  else if (ntc == 5) serialWriteProgString(TS_Cold_Message);
  else if (ntc == 6) serialWriteProgString(TS_Hot_Message);
}

const static char VINDPM_Mode_Message [] PROGMEM = "VINDPM Mode: ";
const static char VINDPM_Relative_Message [] PROGMEM = "Relative VINDPM Threshold";
const static char VINDPM_Absolute_Message [] PROGMEM = "Absolute VINDPM Threshold";
const static char VINDPM_Value_Message [] PROGMEM = "VINDPM value available but not implemented";

void printREG0D(){
  byte data = readRegister(0x0D);
  serialWriteChar("\n");
  //print VINDPM status
  serialWriteProgString(VINDPM_Mode_Message);
  byte mode = data >> 7;
  if      (mode == 0) serialWriteProgString(VINDPM_Relative_Message);
  else if (mode == 1) serialWriteProgString(VINDPM_Absolute_Message);

  //print VINDPM value
  serialWriteProgString(VINDPM_Value_Message);
}

const static char Thermal_Status_Message [] PROGMEM = "Thermal status: ";
const static char Thermal_Throttling_Message [] PROGMEM = "Thermal throttling";
const static char BAT_Voltage_Message [] PROGMEM = "BAT voltage: ";

void printREG0E(){
  byte data = readRegister(0x0E);
  serialWriteChar("\n");
  //print Thermal status
  serialWriteProgString(Thermal_Status_Message);
  byte thermal = data >> 7;
  if      (thermal == 0) serialWriteProgString(Normal_Message);
  else if (thermal == 1) serialWriteProgString(Thermal_Throttling_Message);

  //print Vbat voltage
  serialWriteProgString(BAT_Voltage_Message);
  byte voltage = data << 1;
  voltage = voltage >> 1;
  int value = ((voltage & 0b01000000) >> 6) * 1280 + ((voltage & 0b00100000) >> 5) * 640 + ((voltage & 0b00010000) >> 4) * 320 
              + ((voltage & 0b00001000) >> 3) * 160 + ((voltage & 0b00000100) >> 2) * 80 + ((voltage & 0b00000010) >> 1) * 40
              + (voltage & 0b00000001) * 20 + 2304;
  serialWriteString(integerToString(value));
  serialWriteString("mV");
}

const static char SYS_Voltage_Message [] PROGMEM = "SYS voltage: ";
void printREG0F(){
  byte voltage = readRegister(0x0F);
  serialWriteChar("\n");

  //print SYS voltage
  serialWriteProgString(SYS_Voltage_Message);
  int value = ((voltage & 0b01000000) >> 6) * 1280 + ((voltage & 0b00100000) >> 5) * 640 + ((voltage & 0b00010000) >> 4) * 320 
              + ((voltage & 0b00001000) >> 3) * 160 + ((voltage & 0b00000100) >> 2) * 80 + ((voltage & 0b00000010) >> 1) * 40
              + (voltage & 0b00000001) * 20 + 2304;
  serialWriteString(integerToString(value));
  serialWriteString("mV");
}

const static char TS_VS_REGN_Message [] PROGMEM = "TS voltage vs REGN: ";
void printREG10(){
  byte data = readRegister(0x10);
  serialWriteChar("\n");

  //print TS voltage percentage of REGN
  byte voltage = data << 1;
  voltage = voltage >> 1;
  serialWriteProgString(TS_VS_REGN_Message);
  int value = ((voltage & 0b01000000) >> 6) * 2976 + ((voltage & 0b00100000) >> 5) * 1488 + ((voltage & 0b00010000) >> 4) * 744 
              + ((voltage & 0b00001000) >> 3) * 372 + ((voltage & 0b00000100) >> 2) * 186 + ((voltage & 0b00000010) >> 1) * 93
              + (voltage & 0b00000001) * 46 + 2100;
  float percentage = (float) value / 100;
  //Use double to str this way:  dtostrf(floatVar, minStringWidthIncDecimalPoint, numVarsAfterDecimal, charBuf);
  char buf[10];  
  dtostrf(percentage, 6, 2, buf);
  serialWriteString(buf);
  serialWriteChar('%');
}

const static char VBUS_Voltage_Message [] PROGMEM = "VBUS voltage: ";
void printREG11(){
  byte voltage = readRegister(0x11);
  serialWriteChar("\n");

  //print vbus voltage
  serialWriteProgString(VBUS_Voltage_Message);
  unsigned int value = ((voltage & 0b01000000) >> 6) * 6400 + ((voltage & 0b00100000) >> 5) * 3200 + ((voltage & 0b00010000) >> 4) * 1600 
              + ((voltage & 0b00001000) >> 3) * 800 + ((voltage & 0b00000100) >> 2) * 400 + ((voltage & 0b00000010) >> 1) * 200
              + (voltage & 0b00000001) * 100 + 2600;
  serialWriteString(integerToString(value));
  serialWriteString("mV");
}

const static char IBAT_Current_Message [] PROGMEM = "Charge current (Ibat): ";
void printREG12(){
  byte current = readRegister(0x12);
  serialWriteChar("\n");
  
  //print charge current
  serialWriteProgString(IBAT_Current_Message);
  int value = ((current & 0b01000000) >> 6) * 3200 + ((current & 0b00100000) >> 5) * 1600 + ((current & 0b00010000) >> 4) * 800 
              + ((current & 0b00001000) >> 3) * 400 + ((current & 0b00000100) >> 2) * 200 + ((current & 0b00000010) >> 1) * 100
              + (current & 0b00000001) * 50;
  serialWriteString(integerToString(value));
  serialWriteString("mA");
}

const static char VINDPM_Message [] PROGMEM = "VINDPM: ";
const static char IINDPM_Message [] PROGMEM = "IINDPM: ";
const static char Input_Current_Limit_Message [] PROGMEM = "Input Current Limit (if ICO enabled): ";
const static char Yes_Message [] PROGMEM = "Yes";
const static char No_Message [] PROGMEM = "No";
void printREG13(){
  byte data = readRegister(0x13);
  serialWriteChar("\n");
  //print VINDPM status
  serialWriteProgString(VINDPM_Message);
  byte vindpm = data >> 7;
  if      (vindpm == 0) serialWriteProgString(No_Message);
  else if (vindpm == 1) serialWriteProgString(Yes_Message);

  serialWriteProgString(IINDPM_Message);
  byte iindpm = data << 1;
  iindpm = iindpm >> 7;
  if      (iindpm == 0) serialWriteProgString(No_Message);
  else if (iindpm == 1) serialWriteProgString(Yes_Message);

  //print input current limit
  serialWriteProgString(Input_Current_Limit_Message);
  byte current = data;
  int value = ((current & 0b00100000) >> 5) * 1600 + ((current & 0b00010000) >> 4) * 800 + ((current & 0b00001000) >> 3) * 400
              + ((current & 0b00000100) >> 2) * 200 + ((current & 0b00000010) >> 1) * 100 + (current & 0b00000001) * 50 + 100;
  serialWriteString(integerToString(value));
  serialWriteString("mA");
}

const static char ICO_Message [] PROGMEM = "ICO status: ";
const static char Optimizing_Message [] PROGMEM = "Optimizing...";
const static char Max_Current_Message [] PROGMEM = "Max current detected";
void printREG14(){
  byte data = readRegister(0x14);
  serialWriteChar("\n");
  //print ICO optimization status
  serialWriteProgString(ICO_Message);
  byte ico = data << 1;
  ico = ico >> 7;
  if      (ico == 0) serialWriteProgString(Optimizing_Message);
  else if (ico == 1) serialWriteProgString(Max_Current_Message);
}
