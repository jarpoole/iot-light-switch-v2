//User files
#include "Constants.h"
#include "BoardV2.h"

//System libraries
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <avr/sleep.h>
#include <avr/wdt.h>
#include <avr/pgmspace.h>
#include <util/twi.h>

//Modified RadioHead library
#include "./radiohead-ask-atmega328p/RadioHead.h"
#include "./radiohead-ask-atmega328p/RH_ASK.h"
#include "./radiohead-ask-atmega328p/RH_ASK.cpp"
#include "./radiohead-ask-atmega328p/RHCRC.h"
#include "./radiohead-ask-atmega328p/RHCRC.cpp"
#include "./radiohead-ask-atmega328p/RHGenericDriver.cpp"
#include "./radiohead-ask-atmega328p/RHGenericDriver.h"

#include "./pwmservo-atmega328p/PWMServo.h"
#include "./pwmservo-atmega328p/PWMServo.cpp"

//From documentation: RH_ASK (uint16_t speed=2000, uint8_t rxPin=11, uint8_t txPin=12, uint8_t pttPin=10, bool pttInverted=false)
//pttPin = -1 will disable push to talk functionality
RH_ASK ask_driver = RH_ASK(500, RECEIVER, TRANSMITTER, -1, false);

PWMServo servo;

volatile long lastButtonPressedTime = 0;
volatile bool lastButtonState = false;

volatile bool switchOn = false;
volatile bool debugOn = false;           

//ISR Toggles
volatile bool requestSwitchOn = false;
volatile bool requestSwitchOff = false;
volatile bool requestSwitchToggle = false;
volatile bool requestEnableSerial = false;
volatile bool requestDisableSerial = false;

volatile bool requestBeep = false;
volatile byte numBeeps = 0;
volatile bool requestNewPollRate = false;
volatile byte pollRate = 0;

int main (void){
   
  initialize();
  beep(5,10);
  
  while(true){
    serialWriteString("Awake\n");
    //printAllREG();
    processISRUpdates();                //Check for changes generated by the ISR
    
    
    /*
    const int wakeupLen = 10;
    byte wakeup[wakeupLen];
    for(int i = 0; i < wakeupLen; i++){
      wakeup[i] = WAKE_UP;
    }
    transmitASKBytes(wakeup, wakeupLen);        
    //WAKE_UP
    */

    /*
    serialWriteString( integerToHex( receiveASKByte() ) );
    serialWriteString("\n");
    */ 
    
    byte buf[6] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
    //byte buf[6];
    byte len = sizeof(buf);
    receiveASKBytes(buf, &len);  //blocking
    _delay_ms(10);
    transmitASKByte(ACK);
    transmitASKByte(ACK);
    transmitASKByte(ACK);
    
    for(int i = 0; i < len; i++){
      serialWriteString(integerToHex(buf[i]));
      serialWriteString(" ");
    }
    serialWriteString("\n");
   
    processASKCommands(buf,len);             
    processISRUpdates();                //Check for changes generated by the ISR
   
    serialWriteString("Asleep\n");
    _delay_ms(50);
    sleep();
    
  }
}

void initialize() {
  //_delay_ms(500);
  
  MCUSR &= ~(1<<WDRF); //Always clear the watchdog system reset flag on startup, p45
  WDTCSR &= ~(1<<WDE); //Always clear the watchdog system reset mode on startup, p45
  
  //----------------------Initialize IO-------------------------
  pinMode(BUZZER, OUTPUT);
  pinMode(BUTTON, INPUT);
  pinMode(LED, INPUT);
  attachInterrupt(digitalPinToInterrupt(BUTTON), buttonISR, RISING);
 
  enableSerial();                      //---------------------FIX ME Should be disabled by default---------------------
  
  pinMode(SERVO_ENABLE, OUTPUT);
  digitalWrite(SERVO_ENABLE, LOW);

  //---------------------Initialize Radio------------------------
  pinMode(TRANSMITTER, OUTPUT);
  pinMode(RECEIVER, INPUT);
  pinMode(RF_ENABLE, OUTPUT);           //---------------------FIX ME This is specific to p-channel fets, Off is HIGH, On is LOW---------------------
  digitalWrite(RF_ENABLE, LOW); 
  ask_driver.init();

  //---------------------Initialize BMS--------------------------
  twiBegin();                         //FIX ME (twi shouldn't be on by default?)
  pinMode(BMS_INTERRUPT, INPUT);
  attachInterrupt(digitalPinToInterrupt(BMS_INTERRUPT), bmsISR, FALLING);
  pinMode(BMS_OTG, OUTPUT);

  setOTG_CONFIG(true);      //enable boost mode
  setCHG_CONFIG(false);     //Disable charging
  setCONV_RATE(true);       //enable continuous ADC for testing, seems charging needs to be disabled to stop repeated interrupts https://e2e.ti.com/support/power-management/f/196/t/749914
  enableWatchdog(false);    //Disable watchdog
  twiWriteRegister(0x0A, 0x77); //Set BOOST_LIM value to 111 = 2.45A
  setSTAT_DIS(true);

  initializeTimer2Sleep();
  SMCR|=(1<<SM1)|(1<<SM0); //Set sleep mode control register to PowerSave Mode (Bits SM2 SM1 SM0 = 011 , p38)
  sei();   //Enable global interrupts
}

void initializeTimer2Sleep(){
    //Disable timer2 interrupts by zeroing OCIE2A, OCIE2B and TOIE2
    TIMSK2  = 0;
    //Enable asynchronous mode, Only other R/W bit in ASSR is EXCLK which should be 0
    ASSR  = (1<<AS2);
    //set initial counter value
    TCNT2=0;
    //set OCR2B to 128 (approx 4sec), This value should set the frequency of the interrupts
    OCR2B = 0b10000000;
    //OCR2B = 0b00100000;
    //set prescaller 1024
    TCCR2B |= (1<<CS22) | (1<<CS21) | (1<<CS20);
    //wait for registers TCN2UB, OCR2BUB and TCR2BUB to update by checking status is ASSR
    while ( (1<<TCN2UB)&ASSR | (1<<TCR2BUB)&ASSR | (1<<TCR2BUB)&ASSR);
    //clear interrupt flags;  "Output Compare Flag 2 B" and "Timer/Counter2 Overflow Flag"
    TIFR2  = (1<<TOV2) | (1<<OCF2B);
    //enable OCIE2B interrupt to trigger when compare B matches
    TIMSK2  = (1<<OCIE2B);
}

void sleep(){
  initializeTimer2Sleep();
  cli();           //Disable global interrupts because timed sequence follows
  SMCR |= (1<<SE); //Set "Sleep Mode Control Register" Sleep Enable, SE, Bit = 1, p38
  sei();           //Garentees that the next instruction is executed
  sleep_cpu();     //Issue sleep instruction. This cannot be done by setting a register
  //asm volatile("sleep"::); //Assembly version of sleep_cpu();

        //Sleeping until interrupt

  SMCR &= ~(1<<SE); //Disable sleep enable after wakeup
}
ISR(TIMER2_COMPB_vect){    //fires on wakeup
    asm volatile("nop"::);
}

void processISRUpdates(){
  if(requestSwitchToggle){
    toggleSwitch();
    requestSwitchToggle = false;
  }
  if(requestSwitchOn){
    turnOn();
    requestSwitchOn = false;
  }
  if(requestSwitchOff){
    turnOff();
    requestSwitchOff = false;
  }
  if(requestEnableSerial){
    enableSerial();
    requestEnableSerial = false;
  }
  if(requestDisableSerial){
    disableSerial();
    requestDisableSerial = false;
  }
  if(requestBeep){
    beep(numBeeps, 10);
    requestBeep = false;
  }
  if(requestNewPollRate){
    requestNewPollRate = false;
  }
}
void buttonISR(){
    requestSwitchToggle = true;
}
void bmsISR(){
    //serialWriteString("bms!\n");
}

void toggleSwitch(){
  if(switchOn){
    beep(1, 10);
    turnOff();
  }else{
    beep(2, 10);
    turnOn();
  }
}
void turnOn(){
  digitalWrite(BMS_OTG, HIGH); //enable boost mode
  _delay_ms(BMS_OTG_TIME);
  
  servo.attach(SERVO);
  digitalWrite(SERVO_ENABLE, HIGH);
  _delay_ms(15);
  servo.write(ONPOSITION);
  _delay_ms(MOVE_TIME);
  digitalWrite(SERVO_ENABLE, LOW);
  servo.detach();
  switchOn = true;

  digitalWrite(BMS_OTG, LOW);  //disable boost mode
}
void turnOff(){
  digitalWrite(BMS_OTG, HIGH); //enable boost mode
  _delay_ms(BMS_OTG_TIME);
  
  servo.attach(SERVO);
  digitalWrite(SERVO_ENABLE, HIGH);
  _delay_ms(15);
  servo.write(OFFPOSITION);
  _delay_ms(MOVE_TIME);
  digitalWrite(SERVO_ENABLE, LOW);
  servo.detach();
  switchOn = false;

  digitalWrite(BMS_OTG, LOW); //enable boost mode
}
const static char Enable_Serial_Message [] PROGMEM = "Serial enabled\n";
void enableSerial(){
  serialBegin();
  serialWriteProgString(Enable_Serial_Message);
  debugOn = true;
}
const static char Disable_Serial_Message [] PROGMEM = "Goodbye\n";
void disableSerial(){
  serialWriteProgString(Disable_Serial_Message);
  //Serial.end();
  debugOn = false;
}
void beep(int num, int timeMillis){
    for(int i = 0; i < num; i++){
        digitalWrite(BUZZER, HIGH);
        _delay_ms(timeMillis);
        digitalWrite(BUZZER, LOW);
        if (i < num -1){
            _delay_ms(timeMillis*2);
        }
    }
}
void led_blink(int num, int timeMillis){
    for(int i = 0; i < num; i++){
        pinMode(LED, OUTPUT);
        digitalWrite(LED, LOW);
        _delay_ms(timeMillis);
        pinMode(LED, INPUT);
        if (i < num -1){
            _delay_ms(timeMillis*2);
        }
    }
}

//*********************************Conversion functions************************************************//
char outputString[80]; // general output string, 80 bytes

char* longToString(long n){
  ltoa(n, outputString, 10);    // base 10
  return outputString;
}
char* integerToString(int n){   // returns outputString
  itoa(n, outputString, 10);    // itoa is for integers, 10 is for base 10 (could use 2 for binary, 16 for hex)
  return outputString;
}
char* integerToHex(uint32_t n){ // can be any sort of number, long, byte, uint8,16,32 etc
  ltoa(n, outputString, 16);    // base 16 is binary, returns lower case A-F
  return outputString;
}

//*********************************Serial functions************************************************//
unsigned char serialCheckRxComplete(void){
  return( UCSR0A & _BV(RXC0)) ;         // nonzero if serial data is available to read.
}
unsigned char serialCheckTxReady(void){
  return( UCSR0A & _BV(UDRE0) ) ;       // nonzero if transmit register is ready to receive new data.
}
unsigned char serialReadChar(void){
  while (serialCheckRxComplete() == 0); // While data is NOT available to read
  return UDR0;
}
void serialWriteChar(unsigned char DataOut){
  while (serialCheckTxReady() == 0);   // while NOT ready to transmit
  UDR0 = DataOut;
}
void serialWriteString(const char* string){
  const char* ptr = string;
  while(*ptr != 0){
    serialWriteChar(*ptr);
    ptr++;
  }
}
void serialWriteProgString(const char* ptr){
  char c;
  if (!ptr) 
    return;
  while ((c = pgm_read_byte(ptr++)))
    serialWriteChar(c);
}
void serialBegin(){
  UBRR0H = (unsigned char)(CALC_UBRR>>8); //Set baud rate
  UBRR0L = (unsigned char) CALC_UBRR;     //Set baud rate
  UCSR0B = (1<<RXEN0)|(1<<TXEN0);         //Enable receiver and transmitter
  UCSR0C = (3<<UCSZ00);                   // Frame format: 8data, No parity, 1stop bit
  //UCSR0A |= _BV(U2X0);                  //Enable USE_2X (Jared added this)
}

//*********************************RH_ASK wrapper functions****************************************//
void processASKCommands(byte* commands, int len){
  byte* ptr = commands;
  while(*ptr != SLEEP){
    if(*ptr == BEEP){
        ptr++;
        numBeeps = *ptr;
        requestBeep = true;
    }else if(*ptr == SET_POLL_RATE){
        ptr++;
        pollRate = *ptr;
        requestNewPollRate = true;
    }else if(*ptr == SWITCH_ON){
        requestSwitchOn = true;
    }else if(*ptr == SWITCH_OFF){
        requestSwitchOff = true;
    }else if(*ptr == SWITCH_TOGGLE){
        requestSwitchToggle = true;
    }else if(*ptr == ENABLE_SERIAL){
        requestEnableSerial = true;
    }else if(*ptr == DISABLE_SERIAL){
        requestDisableSerial = true;
    }else if(*ptr == SLEEP){
        return;
    }
    ptr++;
  }
}
byte receiveASKByte(){
    ask_driver.init();
    uint8_t buf[1] = {0};
    uint8_t buflen = sizeof(buf);
    while(!ask_driver.recv(buf, &buflen));
    return(buf[0]); 
}
void receiveASKBytes(byte* buf, byte* len){
    ask_driver.init();
    while(!ask_driver.recv(buf, len));
}

void transmitASKByte(byte data){
    ask_driver.init();
    ask_driver.send(&data, 1);
    ask_driver.waitPacketSent();
}
void transmitASKBytes(byte* data, int len){
    ask_driver.init();
    ask_driver.send(data, len);
    ask_driver.waitPacketSent();   
}
byte checkASKByte(){
    uint8_t buf[1];
    uint8_t buflen = sizeof(buf);
    if(ask_driver.recv(buf, &buflen)){
        return(buf[0]); 
    }else{
        return NULL;
    }
}

//*********************************twi functions****************************************//
//https://github.com/knightshrub/I2C-master-lib/blob/master/i2c_master.c
uint8_t twiReadRegister(uint8_t address){
    twiStart();
    twiWrite(BMS_WRITE_ADDR);     //Select BMS in write mode
    twiWrite(address);            //Select register
    twiStart();
    twiWrite(BMS_READ_ADDR);      //Select BMS in read mode
    uint8_t data = twiReadNACK(); //Send NACK right away because we are only reading one byte
    twiStop();
    return data;
}
void twiWriteRegister(uint8_t address, uint8_t data){
    twiStart();
    twiWrite(BMS_WRITE_ADDR);  //Select BMS in write mode
    twiWrite(address);         //Select register
    twiWrite(data);            //Write data 
    twiStop();
}
void twiBegin(){
    //SCL_FREQ = F_CPU / (16+2*TWBR*PreScale), if we want SCL 100kHz  then TWSR*TWBR = 32
    PRR &= ~(1<<PRTWI); //Enable TWI clock from sleep
    TWSR = 0x00;        //Don't need prescaler so set to 1
    TWBR = 0x20;        //Set TWBR=32(dec), should set SCL to 100kHz
    TWCR = (1<<TWEN);   //enable TWI
}
void twiEnd(){
    TWCR &= ~(1<<TWEN); //Disable TWI
    PRR |= (1<<PRTWI);  //Disable TWI clock for sleep
}
uint8_t twiStart(){
    TWCR = 0;                                //Reset TWI control register
    TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);  //TWINT will be set (written to 0) when start is actually sent
    //while ( TWCR & (1<<TWINT) != 0);       //Wait until TWINT = 0
    while( !(TWCR & (1<<TWINT)) );           //Wait for end of transmission
    if((TWSR & 0xF8) != TW_START){
      return 1; 
    }
    return 0;
}
void twiStop(){
    TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
}
uint8_t twiWrite(uint8_t u8data){
    TWDR = u8data;
    TWCR = (1<<TWINT)|(1<<TWEN);
    //while ( TWCR & (1<<TWINT) != 0); //Wait until TWINT = 0
    while( !(TWCR & (1<<TWINT)) );     // wait for end of transmission
  
    if( (TWSR & 0xF8) != TW_MT_DATA_ACK ){
      return 1; 
    }
    return 0;
}
uint8_t twiReadACK(){ 
    TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
    //while ( TWCR & (1<<TWINT) != 0);         //Wait until TWINT = 0
    while( !(TWCR & (1<<TWINT)) ); // wait for end of transmission
    return TWDR;
}
uint8_t twiReadNACK(){
    TWCR = (1<<TWINT)|(1<<TWEN);
    //while ( TWCR & (1<<TWINT) != 0);         //Wait until TWINT = 0
    while( !(TWCR & (1<<TWINT)) ); // wait for end of transmission
    return TWDR;
}
uint8_t twiGetStatus(){
    uint8_t statusByte;
    statusByte = TWSR & 0xF8; //mask status
    return statusByte;
}
void twiWriteRegisterBit(byte address, int pos, bool value){
  byte currentData = twiReadRegister(address);         //Read the current state
  currentData = bitWrite(currentData, pos, value);     //Change the specified bit
  twiWriteRegister(address, currentData);              //Write the changes
}

//*********************************BMS functions****************************************//
void setCONV_RATE(bool value){ //Configure continuous ADC updates = TRUE, one shot mode = FALSE
  twiWriteRegisterBit(0x02, 6, value);
}
void setOTG_CONFIG(bool value){
  twiWriteRegisterBit(0x03, 5, value);
}
void setCHG_CONFIG(bool value){
  twiWriteRegisterBit(0x03, 4, value);
}
void setSTAT_DIS(bool value){
  twiWriteRegisterBit(0x07, 6, value);
}
void setWD_RST(bool value){
  twiWriteRegisterBit(0x03, 6, value);
}
void enableWatchdog(bool value){ //00 for disabled, 01 for 40s, 10 for 80s and 11 for 160s
  int bit5;
  int bit4;
  if(value){ bit5 = 0; bit4 = 1; }
  else{      bit5 = 0; bit4 = 0; }
  byte currentData = twiReadRegister(0x07);         
  currentData = bitWrite(currentData, 5, bit5);  
  currentData = bitWrite(currentData, 4, bit4); 
  twiWriteRegister(0x07, currentData);
}

//**********************************Print methods**********************************************//
void printAllREG(){
  
  serialWriteChar('\n');
  for(int i = 0; i < 50; i++) serialWriteChar('*');
  serialWriteChar('\n');

  printREGBinary(0x00);
  printREGBinary(0x01);
  printREGBinary(0x02);
  printREGBinary(0x03);
  printREGBinary(0x04);
  printREGBinary(0x05);
  printREGBinary(0x06);
  printREGBinary(0x07);
  printREGBinary(0x08);
  printREGBinary(0x09);
  printREGBinary(0x0A);
  serialWriteChar('\n');

  //Registers 0B to 14 are primarily read only,
  printREG0B();
  serialWriteChar('\n');
  printREG0C();
  serialWriteChar('\n');
  printREG0D();
  serialWriteChar('\n');
  printREG0E();
  serialWriteChar('\n');
  printREG0F();
  printREG10();
  printREG11();
  printREG12();
  serialWriteChar('\n');
  printREG13();
  serialWriteChar('\n');
  printREG14();

  serialWriteChar('\n');
  for(int i = 0; i < 50; i++) serialWriteChar('*');
  serialWriteChar('\n');
}

const static char Register_[] PROGMEM = "Register ";
void printREGBinary(byte address){
  byte data = twiReadRegister(address);
  byte mask = 0b10000000;
  
  serialWriteProgString(Register_);
  serialWriteString("0x");
  serialWriteString(integerToHex(address));
  serialWriteString(": ");
  
  for(int i = 0; i<8; i++){
    if(((mask >> i) & data) == (mask>>i)){
      serialWriteChar('1');
    }else{
      serialWriteChar('0');
    }
  }
  serialWriteChar('\n');
}

const static char Charger_Status_Message [] PROGMEM = "Charger status: ";
const static char No_Charger_Message [] PROGMEM = "No charger";
const static char USB_Host_SDP_Message [] PROGMEM = "USB Host SDP";
const static char USB_CDP_Message [] PROGMEM = "USB CDP (1.5A)";
const static char USB_DCP_Message [] PROGMEM = "USB DCP (3.25A)";
const static char MaxCharge_Message [] PROGMEM = "Adjustable High Voltage DCP (MaxCharge) (1.5A)";
const static char Unknown_Adapter_Message [] PROGMEM = "Unknown Adapter (500mA)";
const static char Non_Standard_Adapter_Message [] PROGMEM = "Non-Standard Adapter (1A/2A/2.1A/2.4A)";
const static char OTG_Mode_Message [] PROGMEM = "OTG mode";

const static char Charging_Mode_Message [] PROGMEM = "Charging mode: ";
const static char Not_Charging_Message [] PROGMEM = "Not Charging";
const static char Pre_Charging_Message [] PROGMEM = "Pre-charge";
const static char Fast_Charging_Message [] PROGMEM = "Fast Charging";
const static char Charge_Termination_Done_Message [] PROGMEM = "Charge Termination Done";

const static char Power_Status_Message [] PROGMEM = "Power status: ";
const static char Error_Message [] PROGMEM = "Error";
const static char Good_Message [] PROGMEM = "Good";

const static char VSYS_Message [] PROGMEM = "VSYS Regulation Status: ";
const static char No_VSYS_Reg_Message [] PROGMEM = "NOT in VSYSMIN regulation (BAT > VSYSMIN)";
const static char VSYS_Good_Message [] PROGMEM = "Good (BAT < VSYSMIN)";

void printREG0B(){
  byte data = twiReadRegister(0x0B);
  serialWriteProgString(Charger_Status_Message);   //print charger information
  
  byte charger = data >> 5;
  if      (charger == 0) serialWriteProgString(No_Charger_Message);
  else if (charger == 1) serialWriteProgString(USB_Host_SDP_Message);
  else if (charger == 2) serialWriteProgString(USB_CDP_Message);
  else if (charger == 3) serialWriteProgString(USB_DCP_Message);
  else if (charger == 4) serialWriteProgString(MaxCharge_Message);
  else if (charger == 5) serialWriteProgString(Unknown_Adapter_Message);
  else if (charger == 6) serialWriteProgString(Non_Standard_Adapter_Message);
  else if (charger == 7) serialWriteProgString(OTG_Mode_Message);
  serialWriteChar('\n');

  //print charging status
  serialWriteProgString(Charging_Mode_Message);
  byte chargeStatus = data << 3;
  chargeStatus = chargeStatus >> 6;
  if      (chargeStatus == 0) serialWriteProgString(Not_Charging_Message);
  else if (chargeStatus == 1) serialWriteProgString(Pre_Charging_Message);
  else if (chargeStatus == 2) serialWriteProgString(Fast_Charging_Message);
  else if (chargeStatus == 3) serialWriteProgString(Charge_Termination_Done_Message);
  serialWriteChar('\n');

  //print power good
  serialWriteProgString(Power_Status_Message);
  byte powerStatus = data << 4;
  powerStatus = powerStatus >> 7;
  if      (powerStatus == 0) serialWriteProgString(Error_Message);
  else if (powerStatus == 1) serialWriteProgString(Good_Message);
  serialWriteChar('\n');

  //print power good
  serialWriteProgString(VSYS_Message);
  byte vsysStatus = data << 7;
  vsysStatus = vsysStatus >> 7;
  if      (powerStatus == 0) serialWriteProgString(No_VSYS_Reg_Message);
  else if (powerStatus == 1) serialWriteProgString(VSYS_Good_Message);
  serialWriteChar('\n');
}

const static char Watchdog_Message [] PROGMEM = "Watchdog status: ";
const static char Normal_Message [] PROGMEM = "Normal";
const static char Timer_Expired_Message [] PROGMEM = "Timer expired";

const static char Boost_Status_Message [] PROGMEM = "Boost status: ";
const static char VBUS_Overloaded_Message [] PROGMEM = "VBUS overloaded in OTG, or VBUS OVP, or battery is too low in boost mode";

const static char Input_Fault_Message [] PROGMEM = "Input fault";
const static char Thermal_Shutdown_Message [] PROGMEM = "Thermal shutdown";
const static char Charger_Safety_Message [] PROGMEM = "Charge safety timer expiration";

const static char Battery_Status_Message [] PROGMEM = "Battery status: ";
const static char Battery_Overvoltage_Message [] PROGMEM = "Battery over-voltage";

const static char NTC_Status_Message [] PROGMEM = "NTC status: ";
const static char TS_Warm_Message [] PROGMEM = "TS Warm";
const static char TS_Cool_Message [] PROGMEM = "TS Cool";
const static char TS_Cold_Message [] PROGMEM = "TS Cold";
const static char TS_Hot_Message [] PROGMEM = "TS Hot";

void printREG0C(){
  //Need to read REG0C twice to get the current status
  twiReadRegister(0x0C);
  byte data = twiReadRegister(0x0C);
  
  //print watchdog status
  serialWriteProgString(Watchdog_Message);
  byte watchdog = data >> 7;
  if      (watchdog == 0) serialWriteProgString(Normal_Message);
  else if (watchdog == 1) serialWriteProgString(Timer_Expired_Message);
  serialWriteChar('\n');

  //print boost status
  serialWriteProgString(Boost_Status_Message);
  byte boost = data << 1;
  boost = boost >> 7;
  if      (boost == 0) serialWriteProgString(Normal_Message);
  else if (boost == 1) serialWriteProgString(VBUS_Overloaded_Message);
  serialWriteChar('\n');

  //print charger status
  serialWriteProgString(Charger_Status_Message);
  byte charger = data << 2;
  charger = charger >> 6;
  if      (charger == 0) serialWriteProgString(Normal_Message);
  else if (charger == 1) serialWriteProgString(Input_Fault_Message);
  else if (charger == 2) serialWriteProgString(Thermal_Shutdown_Message);
  else if (charger == 3) serialWriteProgString(Charger_Safety_Message);
  serialWriteChar('\n');

  //print battery status
  serialWriteProgString(Battery_Status_Message);
  byte battery = data << 4;
  battery = battery >> 7;
  if      (battery == 0) serialWriteProgString(Normal_Message);
  else if (battery == 1) serialWriteProgString(Battery_Overvoltage_Message);
  serialWriteChar('\n');

  //print temperature sensor status
  serialWriteProgString(NTC_Status_Message);
  byte ntc = data << 5;
  ntc = ntc >> 5;
  if      (ntc == 0) serialWriteProgString(Normal_Message);
  else if (ntc == 2) serialWriteProgString(TS_Warm_Message);
  else if (ntc == 3) serialWriteProgString(TS_Cool_Message);
  else if (ntc == 5) serialWriteProgString(TS_Cold_Message);
  else if (ntc == 6) serialWriteProgString(TS_Hot_Message);
  serialWriteChar('\n');
}

const static char VINDPM_Mode_Message [] PROGMEM = "VINDPM Mode: ";
const static char VINDPM_Relative_Message [] PROGMEM = "Relative VINDPM Threshold";
const static char VINDPM_Absolute_Message [] PROGMEM = "Absolute VINDPM Threshold";
const static char VINDPM_Value_Message [] PROGMEM = "VINDPM value available but not implemented";

void printREG0D(){
  byte data = twiReadRegister(0x0D);
  
  //print VINDPM status
  serialWriteProgString(VINDPM_Mode_Message);
  byte mode = data >> 7;
  if      (mode == 0) serialWriteProgString(VINDPM_Relative_Message);
  else if (mode == 1) serialWriteProgString(VINDPM_Absolute_Message);
  serialWriteChar('\n');

  //print VINDPM value
  serialWriteProgString(VINDPM_Value_Message);
  serialWriteChar('\n');
}

const static char Thermal_Status_Message [] PROGMEM = "Thermal status: ";
const static char Thermal_Throttling_Message [] PROGMEM = "Thermal throttling";
const static char BAT_Voltage_Message [] PROGMEM = "BAT voltage: ";

void printREG0E(){
  byte data = twiReadRegister(0x0E);

  //print Thermal status
  serialWriteProgString(Thermal_Status_Message);
  byte thermal = data >> 7;
  if      (thermal == 0) serialWriteProgString(Normal_Message);
  else if (thermal == 1) serialWriteProgString(Thermal_Throttling_Message);
  serialWriteChar('\n');

  //print Vbat voltage
  serialWriteProgString(BAT_Voltage_Message);
  byte voltage = data << 1;
  voltage = voltage >> 1;
  int value = ((voltage & 0b01000000) >> 6) * 1280 + ((voltage & 0b00100000) >> 5) * 640 + ((voltage & 0b00010000) >> 4) * 320 
              + ((voltage & 0b00001000) >> 3) * 160 + ((voltage & 0b00000100) >> 2) * 80 + ((voltage & 0b00000010) >> 1) * 40
              + (voltage & 0b00000001) * 20 + 2304;
  serialWriteString(integerToString(value));
  serialWriteString("mV");
  serialWriteChar('\n');
}

const static char SYS_Voltage_Message [] PROGMEM = "SYS voltage: ";
void printREG0F(){
  byte voltage = twiReadRegister(0x0F);

  //print SYS voltage
  serialWriteProgString(SYS_Voltage_Message);
  int value = ((voltage & 0b01000000) >> 6) * 1280 + ((voltage & 0b00100000) >> 5) * 640 + ((voltage & 0b00010000) >> 4) * 320 
              + ((voltage & 0b00001000) >> 3) * 160 + ((voltage & 0b00000100) >> 2) * 80 + ((voltage & 0b00000010) >> 1) * 40
              + (voltage & 0b00000001) * 20 + 2304;
  serialWriteString(integerToString(value));
  serialWriteString("mV");
  serialWriteChar('\n');
}

const static char TS_VS_REGN_Message [] PROGMEM = "TS voltage vs REGN: ";
void printREG10(){
  byte data = twiReadRegister(0x10);
  
  //print TS voltage percentage of REGN
  byte voltage = data << 1;
  voltage = voltage >> 1;
  serialWriteProgString(TS_VS_REGN_Message);
  int value = ((voltage & 0b01000000) >> 6) * 2976 + ((voltage & 0b00100000) >> 5) * 1488 + ((voltage & 0b00010000) >> 4) * 744 
              + ((voltage & 0b00001000) >> 3) * 372 + ((voltage & 0b00000100) >> 2) * 186 + ((voltage & 0b00000010) >> 1) * 93
              + (voltage & 0b00000001) * 46 + 2100;
  float percentage = (float) value / 100;
  //Use double to str this way:  dtostrf(floatVar, minStringWidthIncDecimalPoint, numVarsAfterDecimal, charBuf);
  char buf[10];  
  dtostrf(percentage, 6, 2, buf);
  serialWriteString(buf);
  serialWriteChar('%');
  serialWriteChar('\n');
}

const static char VBUS_Voltage_Message [] PROGMEM = "VBUS voltage: ";
void printREG11(){
  byte voltage = twiReadRegister(0x11);
  
  //print vbus voltage
  serialWriteProgString(VBUS_Voltage_Message);
  unsigned int value = ((voltage & 0b01000000) >> 6) * 6400 + ((voltage & 0b00100000) >> 5) * 3200 + ((voltage & 0b00010000) >> 4) * 1600 
              + ((voltage & 0b00001000) >> 3) * 800 + ((voltage & 0b00000100) >> 2) * 400 + ((voltage & 0b00000010) >> 1) * 200
              + (voltage & 0b00000001) * 100 + 2600;
  serialWriteString(integerToString(value));
  serialWriteString("mV");
  serialWriteChar('\n');
}

const static char IBAT_Current_Message [] PROGMEM = "Charge current (Ibat): ";
void printREG12(){
  byte current = twiReadRegister(0x12);
  
  //print charge current
  serialWriteProgString(IBAT_Current_Message);
  int value = ((current & 0b01000000) >> 6) * 3200 + ((current & 0b00100000) >> 5) * 1600 + ((current & 0b00010000) >> 4) * 800 
              + ((current & 0b00001000) >> 3) * 400 + ((current & 0b00000100) >> 2) * 200 + ((current & 0b00000010) >> 1) * 100
              + (current & 0b00000001) * 50;
  serialWriteString(integerToString(value));
  serialWriteString("mA");
  serialWriteChar('\n');
}

const static char VINDPM_Message [] PROGMEM = "VINDPM: ";
const static char IINDPM_Message [] PROGMEM = "IINDPM: ";
const static char Input_Current_Limit_Message [] PROGMEM = "Input Current Limit (if ICO enabled): ";
const static char Yes_Message [] PROGMEM = "Yes";
const static char No_Message [] PROGMEM = "No";
void printREG13(){
  byte data = twiReadRegister(0x13);

  //print VINDPM status
  serialWriteProgString(VINDPM_Message);
  byte vindpm = data >> 7;
  if      (vindpm == 0) serialWriteProgString(No_Message);
  else if (vindpm == 1) serialWriteProgString(Yes_Message);
  serialWriteChar('\n');

  serialWriteProgString(IINDPM_Message);
  byte iindpm = data << 1;
  iindpm = iindpm >> 7;
  if      (iindpm == 0) serialWriteProgString(No_Message);
  else if (iindpm == 1) serialWriteProgString(Yes_Message);
  serialWriteChar('\n');

  //print input current limit
  serialWriteProgString(Input_Current_Limit_Message);
  byte current = data;
  int value = ((current & 0b00100000) >> 5) * 1600 + ((current & 0b00010000) >> 4) * 800 + ((current & 0b00001000) >> 3) * 400
              + ((current & 0b00000100) >> 2) * 200 + ((current & 0b00000010) >> 1) * 100 + (current & 0b00000001) * 50 + 100;
  serialWriteString(integerToString(value));
  serialWriteString("mA");
  serialWriteChar('\n');
}

const static char ICO_Message [] PROGMEM = "ICO status: ";
const static char Optimizing_Message [] PROGMEM = "Optimizing...";
const static char Max_Current_Message [] PROGMEM = "Max current detected";
void printREG14(){
  byte data = twiReadRegister(0x14);

  //print ICO optimization status
  serialWriteProgString(ICO_Message);
  byte ico = data << 1;
  ico = ico >> 7;
  if      (ico == 0) serialWriteProgString(Optimizing_Message);
  else if (ico == 1) serialWriteProgString(Max_Current_Message);
  serialWriteChar('\n');
}
